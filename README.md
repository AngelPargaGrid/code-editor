# Code Editor Mockup - Monorepo

A modern monorepo containing a code editor application with Angular frontend and Node.js + Express backend.

## Project Structure

```
code-editor-mockup/
├── package.json                 # Root package.json with workspace configuration
├── README.md                    # This file
├── code-editor-frontend/        # Angular application
│   ├── src/
│   │   ├── app/
│   │   │   └── app.component.ts # Main Angular component
│   │   ├── assets/             # Static assets
│   │   ├── index.html          # Main HTML template
│   │   ├── main.ts             # Application bootstrap
│   │   └── styles.scss         # Global styles
│   ├── angular.json            # Angular CLI configuration
│   ├── package.json            # Frontend dependencies
│   ├── tsconfig.json           # TypeScript configuration
│   └── tsconfig.app.json       # App-specific TypeScript config
└── code-editor-backend/        # Node.js + Express API
    ├── src/
    │   ├── routes/
    │   │   ├── code.ts         # Code execution endpoints
    │   │   └── health.ts       # Health check endpoints
    │   ├── utils/
    │   │   └── logger.ts       # Logging utility
    │   ├── app.ts              # Express application setup
    │   ├── config.ts           # Configuration management
    │   └── server.ts           # Server entry point
    ├── .env.example            # Environment variables template
    ├── nodemon.json            # Nodemon configuration
    ├── package.json            # Backend dependencies
    └── tsconfig.json           # TypeScript configuration
```

## Features

### Frontend (Angular)
- Modern Angular 17+ with standalone components
- Responsive design with CSS Grid and Flexbox
- Code editor interface with syntax highlighting support
- Real-time code execution display
- Mobile-friendly responsive layout
- TypeScript support with strict mode

### Backend (Node.js + Express)
- RESTful API with Express.js
- TypeScript for type safety
- Code execution service (mock implementation)
- Health check endpoints
- Request rate limiting
- CORS configuration
- Request logging with Morgan
- Security middleware with Helmet
- Environment-based configuration

## Prerequisites

- Node.js >= 18.0.0
- npm >= 9.0.0
- Git

## Installation

1. **Clone and setup the repository:**
   ```bash
   git clone <repository-url>
   cd code-editor-mockup
   ```

2. **Install all dependencies:**
   ```bash
   npm run install:all
   ```

3. **Setup environment variables:**
   ```bash
   # Copy the example environment file for the backend
   cd code-editor-backend
   cp .env.example .env
   cd ..
   ```

## Running the Application

### Development Mode

**There are two ways to run the application:**
   ```bash
   # 1. Simply run the command. This command will run the front end, back end, and the necessary WebSocket instance for the app to function.
   npm run dev

   #2. Run each instance separately.
   npm run dev:frontend
   npm run dev:ws
   npm run dev:backend
   ```


**Frontend (Angular):**
```bash
npm run dev:frontend
# Frontend will be available at http://localhost:4200
```
**WebSocket:**
```bash
npm run dev:ws
# Frontend will be available at ws://localhost:1234
```

**Backend (Node.js + Express):**
```bash
npm run dev:backend
# Backend will be available at http://localhost:3000
```


### Environment Variables 

#### code-editor-frontend

- `WEBSOCKET_URL`: WebSocket server URL for real-time collaboration
- `API_BASE_URL`: Backend API base URL  
- `COMPLETION_API_URL`: API endpoint for code completion suggestions

#### code-editor-backend

- `GOOGLE_API_KEY` =
- `PORT`= # dev env port


## How to Get Your Gemini API Key

1. Go to https://aistudio.google.com  
2. Sign in with your Google account.  
3. In the left sidebar, select **API keys**.  
4. Click **Create API key**.  
5. Copy your key and store it in an environment variable, for example:

```bash
export GOOGLE_API_KEY="YOUR_API_KEY_HERE"
````

## Flow: Frontend - Backend - Gemini
   1. POST /api/complete 
   The frontend sends the current code snippet to the backend via an HTTP POST request.
   The backend builds a prompt, queries the Gemini model, and returns a code-only suggestion to the frontend.
```bash
Frontend ===POST /api/complete===> Backend => Gemini
````

   2. Backend Response => Frontend
The frontend receives the suggestion generated by Gemini and integrates or displays it in the code editor.
```bash
Frontend <========================= Backend <= Gemini
````
## Flow: Frontend to Frontend interaction
   1. WebSocket (WS) => Yjs Server
When the user types, the frontend sends real-time updates through a WebSocket connection.
These updates contain Yjs operations that represent changes to the shared document.

   2. Yjs Server => Other Clients
The Yjs server applies those updates to the in-memory document and automatically broadcasts the changes to all other connected clients, enabling real-time collaborative editing. 
```bash
Frontend ===WS===> Yjs Server ===UPDATES===> Other clients
````
## Prompt Engineering Explanation
### Prompt
```bash
You are a helpful coding assistant. Continue the user's code by suggesting the next logical lines.

Language: ${language}

User code:
${code}

Guidelines:
- Continue the code without repeating the user's input.
- Respond ONLY with raw code.
- Do not include comments, explanations, or markdown formatting.
- Do not wrap the output in backticks.
- Limit your response to 1–5 lines unless more is explicitly required by the context.
```
### This prompt is structured to make the model behave like a clean, predictable code-autocomplete engine.

- **Role definition:**  
  Telling the model it's a *helpful coding assistant* sets the behavior and keeps the output focused on code.

- **Task instruction:**  
  “Continue the user’s code” forces the model into completion mode instead of rewriting or explaining.

- **Language conditioning:**  
  Explicitly stating the language ensures correct syntax and conventions.

- **Context injection:**  
  The user’s existing code is included so the model can infer structure, indentation, variables, and the logical next steps.

- **Output constraints:**  
  Rules like “ONLY raw code,” “no markdown,” “no comments,” and “1–5 lines” ensure the response is editor-ready, concise, and free of noise.

Overall, the prompt balances context, clarity, and constraints to produce short, high-quality code continuations suitable for real-time autocomplete.

## How Gemini's response is parsed and displayed as CodeMirror completition?

1. The user requests code suggestions from Gemini (Ctrl+space).
2. The EditorService, through "geminiCompletionSource" (gemini-completition.ts), makes a request to the backend, which in turn requests the suggestion from Gemini.
3. The backend sends {suggestion: ""} back to the frontend.
4. Once the suggestion (response = {suggestion: ""}) is in the front end, the geminiCompletionSource wraps it in a Completion object.
5. CodeMirror takes this value and makes it a visual element in the popup window, applying it to the editor when the user selects it.

## How to Test

1. Start all services (frontend, backend, and WebSocket server).
2. Open your browser at: **http://localhost:4200/**
3. Open a second tab or window at the same URL to observe real-time collaborative editing.
4. Type in the editor and press **Ctrl + Space** to trigger an autocomplete suggestion powered by the backend and Gemini.
